# CFM-101-Final-Project
Roboadvisor stock picker.

The strategy we chose was to make the portfolio as risky as possible, which meant targeting the maximum possible absolute difference between its starting and ending value between November 25th and December 2nd (5 trading days). To do so, we identified three main parameters in our control and created/implemented a strategy that could maximize our success by manipulating them.

Firstly, we considered how many stocks we'll be choosing. Given the constraints of the assignment, which is that we can select between 12 and 25 stocks, we reasonably expect to receive a csv file with at least 25 stocks. Now, we recognize that the more stocks a portfolio contains, the more diversified and less risky it is, so we figured it would be reasonable to choose the minimum number of stocks to include, namely 12. Although this does not guarantee that we cannot find a better performing portfolio of 13 or more stocks than the optimal portfolio consisting of 12 stocks, the run-time of our program is another factor to consider, so we decided to restrict the portfolio size to exactly 12 stocksâ€“ which already uses a significant chunk of computational complexity and memory.

In terms of memory, we tried to be as efficient as possible. Throughout the filtering process of the tickers, each time we called the yfinance API (which we determined was the library that made run-times excessively high) we stored the data we called from yfinance in variables, specifically for the .info and .history methods. This ensured that we did not call Yahoo Finance multiple times for the same data. 

The next strategic decision we undertook was to consider how the 12 stocks we'll be choosing are to be selected based on the limited historical data we have, namely the price history of the stocks between January and October 2022. We recalled from class that standard deviation, in the context of stock pricing, is essentially a measure of the average distance between the mean of a stock's price over some time interval (although as Professor Thompson pointed out, it's actually the square root of variance to make the math consistent) and the actual prices for each point on the interval. In any case, standard deviation is a reflection of volatility, which we have already identified as a variable we want to maximize. However, we thought about the possibility of some stocks having generally high volatility in the upward direction versus others having generally high volatility in the downward direction. The effect of combining these classes of stocks into a portfolio would be to cancel out the overall change in portfolio value to some extent, which is counterproductive to our goal of maximizing the change in portfolio value. With this in mind, we decided that we need to consider the correlation of the stocks we are presented with so that the stocks move in about the same direction. However, correlation is a pairwise operation, so it produces one value given two inputs, which means that calculating the correlation of the stocks in a portfolio, where the number of stocks is greater than 2, is an undefined operation. If it were possible, we would simply find all the possible combinations of 12 stocks, create a portfolio out of them, then maximize their standard deviation and the correlation between the 12 stocks. Unfortunately, we had to be more creative than that, so we decided to find the two stocks in the portfolio with the maximum correlation, create an index out of them (as a representative of the average price of those two stocks) and then append the highest correlated stock to that index recursively until the desired amount of stocks are to be added, which in this case was 12. The way we created our index was by adding the prices and scaling the portfolio down such that each stock had a value of $1 initially. Notably, this is a price weighted index, rather than a market cap weighted index. The reason for this is that weighing stocks based on their influence on the overall economy is irrelevant to the task of accurately representing the combined price of two stocks, which is what we want to do. 

In order to take into account standard deviation, we decided that each time we generate a set of 12 stocks using the procedure we described above, we are to remove the stock with the lowest standard deviation and repeat the procedure again, eventually removing stocks with high correlation, but low standard deviation, such that they do not appear in subsequent sets of stocks. The reason why we argue this is an effective strategy is that although a set of stocks may be highly correlated, it is still possible that the prices therein do not vary significantly. So by removing stocks with low standard deviations from the remaining set of stocks one at a time, we are ensuring that the set of 12 stocks generated using the correlation stock picker we describe above is not only correlated, but also has a high variance, the further we get into removing the stocks. The set of 12 stocks chosen out of the generated sets is the one that has the highest difference between end price and start price (from January to October). It might have been a better idea to find the line of best fit and calculate the absolute value of its slope (and try to maximize it) to conduct a more holistic examination of the price patterns of the portfolios, but it's too late now to change our code. I suppose this could be a next step to improving our project, should we choose to do so. 

Once the final portfolio has been decided on, we need to somehow choose the weightings. Clearly, there are an infinite number of possible weightings, even in the restricted interval specified in the assignment of each stock representing between (1/2n)% and 25% of the value of the portfolio. To get around this problem, we decided to randomize the portfolio weights. Even though we will not be able to check all the possible combinations, the more trials we conduct, the closer we will get. Now, the way this works is we select a random real number using a real number generator that is within the given range for each stock, then divide by the sum of those values to ensure that the weightings add to 100%. We also made a reasonable decision to scale down the prices of each stock to only $1 so that the Python Interpreter would have to make less complicated calculations, boosting our run-time (note that this is NOT a marginal difference since we should be doing at least 1000 randomized tests, as specified by the value of the trials variable). Once each stock is assigned a weight for "trials" amount of randomly generated weightings summing to 1, the "optimal" one is selected by once again taking the maximum difference between starting and ending price of the portfolio between our given dates: January and October 2022. 
